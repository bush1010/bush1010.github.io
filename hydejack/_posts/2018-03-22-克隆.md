---
layout: post
title: "克隆"
description: 前端之克隆封装(可即时调用)
tags: 克隆
---

﻿

<h2><p>浅层克隆---不能控制自己啥都克隆</p></h2>
	var obj = {
		name : 'bush',
		age : 19,
		sex : 'male',
		card: ['Apple pay', 'visa']
	}
	var obj1 = {}
	//这里做了一个兼容，如果没有传target 也不会报错
	function clone(origin, target){
		var target = target || {};
		for(var prop in origin){
			target[prop] = origin[prop];
		}
		return target;
	}
	clone(obj, obj1);





	<p>数组也可以for in遍历(数组也是一种特殊的对象)</p>
	var arr = ['a', 1, true];
	for(var prop in arr){
		console.log(arr[prop]);
	}  





	var obj1 = {name : bush, age : 19, sex : 'female', wife : ['wife1']};
	var obj2 = {};


	//遍历对象 for(var prop in obj)
	//1.判断是不是原始值 typeof()  
	//2.判断是数组还是对象 instanceof  toString  constructor
	//3.建立相应的数组或对象
	//递归


	深层克隆---简单来说就是你克隆了我，但我修改东西你并不会跟着我修改
	function deepClone(origin, target){
		var target = target || {},
			toStr = Object.prototype.toString,
			arrStr = "[object Array]";
		for(var prop in origin){
			//为了避免拿原型链上的属性，true的话就继续
			if(origin.hasOwnProperty(prop)){
				//判断是不是原始值,并且排除了null
				if(origin[prop] !== "null" && typeof(origin[prop]) == 'object'){
					//判断是数组还是对象
					//也可以写成三目运算的方式
					target[prop] = toStr.call(origin[prop]) == arrStr ? [] : {}
				/*	if(toStr.call(origin[prop]) == arrStr){
						//是数组
						target[prop] = [];
					}else{
						//否则是对象
						target[prop] = {};
					}   */
					//当做原始的值再次递归
					deepClone(origin[prop], target[prop]);
				//否则是原始值得话再次循环
				}else{
					target[prop] = origin[prop];
				}
			}
		}
		//没有克隆目标就直接return
		return target;
	}


	以上仅供参考
