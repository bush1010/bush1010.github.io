
---
layout: post
title: "节点篇封装大法"
description: 分享
tags: DOM节点篇
---﻿





	//判断是否是元素节点然后放在数组里，最后做出类数组使其更像系统提供的			
		function retElementChild(node){
			var temp = {
				length : 0,
				push : Array.prototype.push,
				splice : Array.prototype.splice
			},
			child = node.childNodes,
			len = child.length;

			for(var i = 0; i < len; i++){
				if(child[i].nodeType === 1){
					temp.push(child[i]);
				}
			}
			return temp;
		}






		//封装retParent功能，给两个值ele(element)、n(number)返回相应父节点
		function retParent(elem, n){			
			while(elem && n){
				elem = elem.parentElement;
				n--;
			}
			return elem;
		}






		//封装myChildren功能，解决以前部分浏览器的兼容性问题
		Element.prototype.myChildren = function (){
			var child = this.childNodes;
			var len = child.length;
			var arr = [];
			for(var i = 0; i < len; i++){
				if(child[i].nodeType === 1){
					arr.push(child[i]);
				}
			}
			return arr;
		}






		//封装hasChildren()方法，不可用children属性
		Element.prototype.hasChildren = function (){
			var child = this.childNodes;
			var len = child.length;
			for(var i = 0; i < len; i++){
				if(child[i].nodeType === 1){
					return true;
				}
			}
			return false;
		}





	/*封装函数，返回元素e的第n个兄弟元素节点，n为正，返回后面的兄弟元素节点，n为负，返回前面的，n  为0，返回自己*/
		function retSibling(e, n){
		 	while(e && n){
				if(n > 0){
					//正常浏览器
					if(e.nextElementSibling){
						e = e.nextElementSibling;
					//针对IE较低版本做的兼容
					}else{
						for(e = e.nextSibling; e && e.nodeType != 1;e.nextSibling);
					}
					n--;
					//n < 0情况
				}else{
					if(e.previousElementSibling){
						e = e.previousElementSibling;
					}else{
						for(e = e.previousSibling; e && e.nodeType != 1; e = e.previousSibling);
					}
					n++;
				}
			}
			return e;
		}
